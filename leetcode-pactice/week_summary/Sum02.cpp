/* 
    LC_106.从中序与后序遍历序列构造二叉树
    后序遍历的最后一个节点为该树的根节点，通过这个信息再去中序序列中找到该节点并将其分为两部分，左边为该节点的左子树，右边为该节点的右子树。
    在通过切割后的中序序列的大小去后序序列里切割。
    可以用vector记录或者用索引记录
*/

/* 
    LC_376. 摆动序列
    我们可以将摆动转换为折线图，如果某节点的前后折线方向不一致，说明其是“摆动节点”
    贪心思想：局部最优：两个摆动节点间没有节点  全局最优：找到摆动序列的最长子序列
    有三种特殊情况：1.波峰或波谷处有平坡。这里要认为规定取哪一边的节点为有效节点，不然长度就大了1.
                    2.首尾两端特殊情况。题目说了有两个不相等的数组也算摆动序列，并且长度为2，所以这里我们可以融合进判断规则里。令result=1（单个节点也是摆动序列），然后首节点通过条件也是摆动节点
                    3.单调坡度处有平坡。让prediff只有在摆动的时候才更新
*/

/* 
    LC_455.分发饼干
    贪心思想：局部最优：大饼干优先分给大胃口（或者小饼干优先分给小胃口的）
*/

/* 
    LC_617.合并二叉树
    让两棵树的节点同步遍历，并且要有返回值（TreeNode*），哪颗树有就返回哪颗的，如果两个数都有就把Tree2的节点值加到Tree1上
*/

/* 
    LC_700.二叉搜索树中的搜索
    二叉搜索树就是排好序的树，比根节点小的值就放在左边，大的放在右边
    用前序遍历一个一个比就行了
*/

/* 
    LC_53. 最大子序和
    贪心思想：局部最优：如果当前遍历到的值大于当前遍历到的值+当前数组的值（或者当前数组的值为负数），这两种情况说明当前数组的值都是对后面的值产生负效果，所以直接舍弃（贪）
*/

/* 
    LC_55. 跳跃游戏
    定义一个变量cover记录当前位置能跳到的最远位置，接着进入循环，同时每前进一个就判断当前的cover范围是否更大，如果更大就修改当前cover的值，
    最后判断如果cover能到最后的位置，那么就直接返回true
*/

/* 
    LC_122.买卖股票的最佳时机 II
    局部最优：只有在明天价格比今天价格高时，才进行一次买卖操作

*/

/* 
    LC_45.跳跃游戏 II
    局部最优：尽可能的往远处跳
    定义一个变量记录当前能跳的最远的位置，同时定义一个变量记录下一步能跳到的最远位置，然后进行遍历，当达到当前能挑到的最远位置的时候就进行一次更新
*/

/* 
    LC_1005.K次取反后最大化的数组和
    第一次局部最优：先让绝对值大的负数取反
    第二次局部最优：先让值小的正数取反
*/